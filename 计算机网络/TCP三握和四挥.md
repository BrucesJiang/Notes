# TCP/IP协议的三次握手和四次挥手
TCP/IP协议是两组不同的协议。IP协议是用来查找地址的，对应网际互联层，TPC协议是用来规范传输规则的，对应着传输层。IP只负责查找地址，具体传输的工作则交由TCP来完成。类似于快递的业务逻辑。货单上填写收货地址的规则以及如何根据地址查找用户，这些规则相当于IP协议；送货时需要打电话，送货，然后交货的过程就是TCP协议保证的过程。

TCP的特性：

- TCP 提供一种面向连接的、可靠的字节流服务
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- TCP 使用校验和，确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

TCP进行数据传输之前会进行三次沟通，一般称为 **三次握手**， 数据传输完断开时要进行四次沟通，一般称为 **四次挥手** 。 在详细描述这两个过程之前，我们首先理解TCP协议中的两个序号和三个标志位的含义：

- `seq`: `sequence number`的缩写，表示所传数据的序号。 TCP进行数据传输时，每个字节都有一个序号，发送数据时会将数据的第一个序号发送给对方，接收方会按照序号检查是否完整接收数据。如果没有完整接收收据就需要重新传送。TCP通过这种方式保证数据完整性。
- `ack`: `acknoledgement number`的缩写， 表示确认号。 接收端用它来给发送端反馈已经成功接收到的数据信息，它的值为希望接收的下一个数据包的起始序号，也就是`ack`值所代表序号前面的数据已经成功接收到了。
- `ACK`: 确认位， 只有`ACK=1`的时候`ack`才起作用。正常通信时`ACK = 1`, 第一次发起请求是因为没有需要确认接收的数据，所以`ACK=0`。
- `SYN`: 同步位， 用于在建立连接时同步序号。 刚开始建立连接时并没有历史接收的数据，所以`ack`也就没有办法设置，这时按照正常机制就无法运行了，`SYN`的作用就是来解决这个问题。当接收端接收到`SYN=1`的报文时就会直接将`ack`设置为接收到的`seq+1`的值。注意这里的值并不是校验后设置的，而是根据`SYN`直接设置的，这样正常的机制就可以运行了，所以	`SYN`叫做同步位。需要注意的是，`SYN`会在前两次握手时窦唯1，这是因为通信双方的`ack`都需要设置一个初始值。
- `FIN`：终止位， 用来在数据传输完毕后释放连接。

传输过程如下图所示：


![tcp_three_four](./images/tcp_three_four.png)

图中上部为`三次握手`，下部为`四次挥手`，这里的四次挥手中画的是客户端提出的中止连接，在实际传输过程中也有可能是服务端提出终止连接请求，它们的处理过程都是一样的。TCP的传输模式是双全工模式，也就是说传输的双方是对等的，可以同时传输数据，所以无论连接还是关闭都需要对双方同时进行。三次握手中的前两次可以保证服务端能够正确接收并返回请求，后两次可以保证客户端能够正确接收并返回请求，而且在三次握手的过程中还使用SYN标志初始化了双方的ack值。四次挥手就是双方分别发送FIN标志来关闭连接并让对方确认。 其中`2MSL`表示两个最大表问段生存时间。

具体解释一下两个部分的含义，首先是 **三次握手**

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。

- 1. 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。

- 2. 第二次握手(SYN=1, ACK=1, seq=y, ACK(num)=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。

- 3. 第三次握手(ACK=1，ACK(num)=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1。 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

**四次挥手的过程**

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

- 1. 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。

- 2. 第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

- 3. 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

- 4. 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。


在传输层的协议除了TCP还有UDP，它们的区别主要是TCP是有连接的，UDP是无连接的，也就是说TCP协议是在沟通好后才会传输数据，而UDP协议是拿到地址后就直接传输，这样产生的结果就是TCP协议传输的数据更加可靠，而UDP协议传输的速度更快。

HTTP协议的底层传输默认使用的是可靠的TCP协议。

- [TCP](https://hit-alibaba.github.io/interview/basic/network/TCP.html)