# 字符串查找算法之KMP理解
## 引言
字符串的一种基本操作就是`字符串查找`：给定一个文本T和一个模式串P，在文本串T中查找一个和该模式串P相等的子串。该问题的解决方法可以很容易的扩展到找出文本中所有和该模式串相等的字串，统计该模式串在文本中出现的次数等等。
解决字符串查找问题我们很容易能够想到的是暴力匹配算法，再者就是很出名的KMP算法。
这里按照顺序进行介绍相关算法思想，算法原理和实现。

我们假设一个问题：一个文本串T和一个模式串P，查找P在T中首次出现的位置。其中T[0...i...N]和P[0...j...M],其中i,j表示两个字符串的指针;M,N表示两个字符串的长度
## 暴力匹配算法
**算法思想：**
将模式P从左到右依次与文本串T对齐匹配，直到第一个子串T[i..M-1]和P相等，或者匹配到T末尾查找结束。
**算法原理：**
假设文本串`T`当前匹配到`i`，模式串`P`匹配到`j`,则有：
 - 如果 `P[j] == T[i]`(当前字符匹配成功)，则 `i++; j++`（继续匹配下一个字符）
 - 如果 `P[j] <> T[i]`(失配)， 则 `i = i - j + 1; j = 0`（一旦失配，i回溯，j重置为0。`此时的必要操作是模式串右移一格`）
**伪代码实现**:

```
Input： S,N,P,M
Output: pos
i <- 0
j <- 0
while i < N and j < M do
    if S[i] == P[j] then
        i ++ ; j ++
    else 
        i = i - j + 1; j = 0
end while

if j == M then
  pos = i - j
else 
  pos = -1

end if

```

通过算法伪代码执行发现：每次失配，文本指针`i`都要回溯并且模式串指针'j'重置；与此同时，失配前的匹配结果就此失效。我们希望是否就可以通过某种方式将二者关联，也就是说，不希望每次失配文本指针`i`回溯，同时，又能用上失配前已经得到的匹配信息。

KMP算法的主旨就是利用已经部分匹配的信息，同时保持文本指针`i`不回溯，通过修改模式指针`j`的位置，让模式串在失配时尽量前移。

## KMP算法
Donald Knuth，James H. Morris, Vaughan Pratt于1977年提出的字符串查找算法。
该算法能够将字符串查找的时间复杂度降低`O(N)` .

**算法思想：**
当出现失配时，我们可以根据已经知晓的部分匹配内容避免将指针回退到已经知晓的字符之前。也就是说， `提前判断如何重新开始查找，而这种判断仅仅取决于模式串P`。
**算法原理**
通过模式串P构建NEXT表，其中NEXT表的作用是一旦文本串T和模式串P在指针i和指针j位置发生失配，NEXT[j]的表明模式串应该在字符T[i]和P[NEXT[j]]处对齐。

我们定义 `NEXT[j] = k` : 已知值`k`, 字串 `P[0...k-1] =  P[j-k...j-1]` .其含义为 `P[j]`之前的模式串子串`P[0...j-1]`中，有长度为`k`的最长真前缀与真后缀相同。

也就是，已知 `NEXT[j] = k`, 求解 `NEXT[j+1] = ?` ：在模式串的前`j+1`个字符中，
 - 如果 `P[j+1] == P[k]`, 则 `NEXT[j + 1] == NEXT[j] + 1 = k + 1`
 - 如果 `P[j+1] != P[k]`, 则 `令 k = NEXT[k]`, 继续搜索前缀，直至 `k = -1(NEXT[0]) 或 P[j] = P[k]`。
着重解释一个下上述第二步：如果发生失配，也就是说，在字符 `P[j+1]`之前不存在长度为`k+1`的真前缀 `P[0...k+1]`与长度为`k+1`的真后缀`P[j-k,j]`相等。那么是否存另外一个`t+1 < k+1`，使得长度更小的真前缀 `P[0...t]`等于长度更小的真后缀`P[j-t...j]`，如果存在，那么`NEXT[j+1] = t+1`。

对于查找算法，其利用了NEXT表作为前进指导，算法如下：
`假设当前，文本串T匹配到i, 模式串P匹配到j`,则：
 - 如果 `j = -1 OR P[j] == T[i]`, 则 `i++; j++`
 - 如果 `j <> -1 AND P[j] <> T[i]`, 则 `j = NEXT[j]`
着重解释一下第二步：这意味着，一旦发生失配，模式串P相对于文本串S向右移动了 `j - NEXT[j]`个位置。

**伪代码实现**
```
//构建NEXT表
Input: P,M
Output: NEXT

NEXT[0] <- -1
j <- 0
k <- -1
while j < M - 1 do  //注意这里的限界
    if k == -1 || P[j] == P[k] then
        NEXT[++j] <- ++k
    else 
        k <- NEXT[k]
    end if
end while

//字符串查找
Input: T,N,P,M,NEXT
Output: Pos

i <- 0
j <- 0 // 注意这里，一开始想的是错误的
while i < N AND j < M do
    if j == -1 || P[i] == p[j] then
        i++; j ++
    else 
        j <- NEXT[j]
    end if
end while

if j == M then
    pos <- i - j
else 
    pos <- -1
end if
```


## 后记
各种改进算法已经深入理解，后续再补充。

2017/11/20



