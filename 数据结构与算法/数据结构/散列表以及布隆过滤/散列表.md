# 目录
1. 基本概念
2. 散列函数
3. 实现方式
4. 特殊的散列
5. 应用
6. 高级主题

# 基本概念
**散列的主要作用** ： 为了解决常规数组或链表在增(insert)、删(delete)、查(search)操作上复杂都过高的问题。除了散列之外，平衡树也可以降低操作的复杂度，但是散列具有更优的平均性能。

**散列的注意事项** ： 
 - 好的散列函数 -- 将元素映射到特定位置，分布越均匀越好
 - 解决散列冲突 -- 不同的元素产生相同的key就会导致冲突，如何很好的解决冲突

**优缺点**
 - 优点 -- 性能高，特别是元素个数确定的时候
 - 缺点 -- 元素个数较少时没有很好的性能优势，无法顺序遍历，元素访问的局部性较差

**影响散列性能的两大因素** 
 - 散列函数 -- 从局部上尽可能地避免元素冲突
 - 负载 -- 从整体上避免冲突过多

如果散列函数效果很差，可能会导致散列相关操作的复杂度退化成O(n); 如果散列函数效果很好，通常相关操作的复杂度只有O(1)

当散列表元素的个数比散列容量大时，通常就会导致散列表访问性能的下降，所以往往需要通过负载因子来限制整个散列表允许的最多元素个数(Java中的hashtable的默认负载因子是0.75).当超过负载后，需要重新分配更大的散列表。重新分配的主要目的并不是因为溢出，而是因为访问性能可能会下降。

当元素个数确定时，可以通过预先分配大于负载的散列表来获得最佳性能。如果元素个数不确定，就需要动态分配空间，或者选择其它数据结构。 

**散列的操作步骤**
1. hash = func(key)
2. index = hash % array_size

一般情况下，key都很复杂，不能直接映射到散列表中(例如字符串、身份证号等)。这时就需要利用散列函数将key转化成可以取余操作的整数。如果key是可以直接调用取余操作的整数，则可以忽略第一步。

## 散列函数
**散列函数的要求**
1. 计算散列值尽可能均匀分布(uniform distribution)
2. 开环散列还需要避免散列值得堆聚(clustering)

**常见的散列函数**
1. 加法
2. 位运算，通常有移位或异或操作
3. 乘法，推荐乘数有 31(java hashcode默认)，131，1313，13131，131313
4. 查表

[Function实现](http://www.partow.net/programming/hashfunctions/)

## 实现方式
### 开放寻址(open addressing)
1. 线性探查(Linear Probing, 最常用)：<img src="http://www.forkosh.com/mathtex.cgi? \Large h_{i} = (h(key)+i)%m, 0 \leq i \leq m-1">
2. 
